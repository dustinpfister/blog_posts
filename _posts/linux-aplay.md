---
title: Linux aplay command and ALSA
date: 2023-06-15 12:37:00
tags: [linux]
layout: post
categories: linux
id: 1052
updated: 2023-06-16 11:11:48
version: 1.5
---

The [Linux aplay](https://linux.die.net/man/1/aplay) command of [ALSA](https://en.wikipedia.org/wiki/Advanced_Linux_Sound_Architecture) is pretty cool as it can be used as a tool to play any kind of raw data as sound. This data can be [piped](/2020/10/09/linux-pipe/) into the standard input of the aplay command, or a file can be passed as a positional argument. Any kind of data can be used as sample data, but to really start using aplay by one way or another it would be best to fine ways to generate sample data.

<!-- more -->

## 1 - Pipe in random data by using cat

Any kind of data can be piped into the standard input of aplay, this includes random data generated by making use of [cat](/2020/11/11/linux-cat/), and dev random. When doing something like this I can use the -d option of aplay to limit the amount of time that this will play to 3 seconds.

```
$ cat /dev/random | aplay -d 3
Playing raw data 'stdin' : Unsigned 8 bit, Rate 8000 Hz, Mono
```

I can set -d option to 0, or just not give any -d option at all sense that is the default which will result in aplay just continuing to play random data as sound until I do a control+c or end the process by whatever means.

## 2 - Formats

By default the format that is used is U8 which is unsigned 8 bit audio. There are a number of other formats that often can be used, however the full list of formats will change from one sound card to another. For the most part thus far I have just been sticking to unsigned 8 bit mono audio

```
$ cat /dev/random | aplay -d 5 -f U8
$ cat /dev/random | aplay -d 5 -f S32_LE
```

## 3 - Sample Rates

The sample rate can also be adjusted by way of the -r option. The main page says that valid values are 2000 through 192000 Hertz, and the default as we can see is 8000 Hertz. The man page also says that if I give a value less than 300 that will be used as a kilohertz which would be that I should be able to give a value like 41 for for 41000 Hertz.

```
$ cat /dev/random | aplay -d 5 -f U8 -r 2000
$ cat /dev/random | aplay -d 5 -f U8 -r 88000
```

## 4 - Using cat and dd to generate 8K bytes of random data for just one second of noise

So far I have been piping in data to aplay by way of using the linux cat command with the use of /dev/random. However another major command I could pipe the random data into would be the [dd command](/2023/06/08/linux-dd/) which has the -bs option that can be used to set, say 8000 bytes blocks, and I can do 60 blocks. This would then result in 60 seconds worth of audio data if it is still 8 Bit Sample Size, and 8000 hertz. However when doing so I will want to make sure that I set the iflag option to fullblock else the resulting file will end up being a bit light because of a partial read error.

```
 $ cat /dev/random | dd bs=8000 count=60 iflag=fullblock > audiodata
60+0 records in
60+0 records out
480000 bytes (480 kB, 469 KiB) copied, 0.0826348 s, 5.8 MB/s
$ aplay -f U8 -r 8000 audiodata
Playing raw data 'audiodata' : Unsigned 8 bit, Rate 8000 Hz, Mono
```

## 5 - Start Using nodejs to create data to then use with aplay

Piping random data into aplay is a nice start, there is also looking into other ways to pipe in all kinds of other not so random data as well. However there is also getting into at least a little programming in order to start getting into the full, fine grain control when it comes to the idea of generating sample data. For this section then I will be doing just that by making use of [nodejs and a little javaScript](/2017/04/05/nodejs-helloworld/) code.

### 5.1 - The waves.js file to use with nodejs

If I am to use nodejs to create some sample data I will want to use [process.stdout.write](/2021/03/18/nodejs-process-stdout/) over that of console.log so that I have control over having an End Of Line or not in the output. I then also make use of a buffer as a way to create an output mode that will be the binary data rather than text data that I will want to then pipe or redirect into aplay. I have found that thus far I mostly want to redirect into a file and then use aplay until I figure out how to address an issue with data that is lost when piping. More on that when we get into the actually usage in the bash prompt.

```js
// POSITIONAL ARGUMENTS
const sample_rate = process.argv[2] || 8000;
const sample_secs = process.argv[3] || 1;
const wave_count = process.argv[4] || 80;
const amplitude = parseFloat( process.argv[5] || 0.45 );
const output_mode = process.argv[6] || 'binary';
// CREATE DATA
const COUNT_SAMPLES = sample_rate * sample_secs;
const SAMPLE_SIZE = 1;
let buff = Buffer.alloc(SAMPLE_SIZE);
let i_sample = 0;
while(i_sample < COUNT_SAMPLES){
    // figure current sample value
    const a_sample = i_sample / COUNT_SAMPLES;
    const a_waves = a_sample * wave_count % 1;
    const n = Math.round( 127.5 - Math.sin( Math.PI * 2 * a_waves ) * (128 * amplitude) );
    // write to buffer, and then to standard output if 'binary' output
    if(output_mode === 'binary'){
        buff.write( n.toString(16), 0, 'hex');
        process.stdout.write( buff );
    }
    // also have a plain 'dec' output for debugging as I write more of these
    if(output_mode === 'dec'){
        process.stdout.write( n.toString(10) + '\n' );
    }
    i_sample += 1;
}
```

### 5.2 - Pipe into aplay with default settings

One way to get started with this is to just pipe the data that this script generates with default settings into aplay with default settings.

```
$ node wave | aplay 
```

This kind of thing will work okay for small use case examples that are about a second or so, but I loose data if I make the tone too long. Not a big deal with this script, but if I really get into this it will become a problem. I am sure that there is a way to address this, must have something to do with the chuck size with the nodejs script maybe. However in any case regardless if I address this or not there are other ways of doing this.

### 5.3 - Redirection

Thus far I have found that if I want to make a long noise I will want to create a large file, and then play that file with aplay. One way to do this would be to make use of redirection.

```
$ node wave 8000 10 800 0.5 binary > adata
$ aplay adata -f U8 -r 8000
```

## Conclusion

The aplay command is then pretty cool as it allows for me to make noise with any kind of binary data, and there might be forms of data that will result in interesting sounds when it comes to just going ahead and using it that way. However if you do know a thing or two about a programming language or two there is doing all kinds of things with everything and anything that there is to work with in that programming environment to generate binary data to then pipe into aplay.


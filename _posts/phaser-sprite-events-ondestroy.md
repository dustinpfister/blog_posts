---
title: The Phaser on destroy event
date: 2018-09-15 15:04:00
tags: [js,phaser]
layout: post
categories: phaser
id: 280
updated: 2018-09-15 20:15:24
version: 1.9
---

Recently I wrote a post on the onKilled event that can be used to attach event handlers to display objects in [Phaser ce](https://photonstorm.github.io/phaser-ce/) that will fire when the kill method is called. In phaser ce the kill method is very different from the destroy method in that the kill method will just put a sprite in a dead state, while the destroy method will completely destroy a sprite all together.

<!-- more -->

## 1 - what to know

This is a post on the sprite.events.onDestroy event in phaser ce that can be used to define some javaScript that is to be called when a display object such as a sprite is completely removed from phaser using the destroy method.

## 2 - A phaser example using sprite.events.onDestroy

For a full working example of using the onDestroy event I put together something that is very similar to the example that I made for my other post on the onKilled event. There is at least one significant difference though, this example does not involve a group of sprites there where created once and then reused. In this example I am adding sprites to a group as needed, and when they are destroyed there are completely removed. In most projects I might prefer to use a set pool of sprites that I reuse, but never the less this is a different approach that in some ways may be a better solution for working with a group of sprites.

### 2.1 - The enemies.js file

For this example I made an enemies.js file that will be a collection of methods that pull a lot of logic out of my state objects resulting in more fine grain code examples. These methods setup a main game data object, make a sprite sheet with canvas, and of course provides a handler to be used with the onDestry event.

#### 2.1.1 - Staring off the module with Enemy.setup

I start off this module by just making a object literal to which I will be appending the methods. I often have a setup method in these finds of modules that is to be called in the create method of a boot state, that is used to set up some values that will be used in the other methods.

```js
var Enemy = {};
 
// setup a game.data object
Enemy.setup = function (game) {
 
    game.data = {
 
        maxEnemies: 5,
        enemies: game.add.group(),
        score: 0
 
    };
 
};
```

One of the values game.data.score is a value that will be incremented in my onDestroy handler that will be coming up later in this example..


#### 2.1.2 - The Enemy.onDestroy handler that will be attached to sprite.events.onDestroy

here is the is handler that I will be attaching to sprite.events.onDestroy when creating a new sprite with my spawn method that I will be getting to shortly.

```js
// The onDestroy method that will be called each time an enemy is killed
Enemy.onDestroy = function (sprite) {
 
    var game = this.game,
    spriteSpeed = (sprite.data.dx + sprite.data.dy) / 8,
    speedBonus = 175, // points bonus for speed.
    perKill = 25; // points per kill
 
    // score formula
    game.data.score += perKill + Math.floor(spriteSpeed * speedBonus);
 
};
```

When using sprite.events.onDestroy I can set the value of the this keyword using one of the arguments when calling sprite.events.onDestroy. In this example each time the onDestroy handler is called the players score will increase with the formula outlined in the method, a common task to happen each time an enemy is destroyed.

#### 2.1.3 - The Enemy.onInputDown handler

```js
// What happens when the player clicks an enemy
Enemy.onInputDown = function (enemy) {
 
    enemy.data.hp -= 1;
 
    if (enemy.data.hp === 1) {
        enemy.frame = 1;
    }
 
    if (enemy.data.hp <= 0) {
        enemy.kill();
    }
 
};
```

#### 2.1.4 - Generating a Sprite.data object

```js
// generate a data object for a sprite
Enemy.genSpriteData = function () {
 
    return {
        dx: Math.random() * 3.5 + 0.5,
        dy: Math.random() * 3.5 + 0.5,
        hp: 2
    };
 
};
```

#### 2.1.5 - Making a sheet with canvas

```js
// make a sprite sheet
Enemy.mkSheet = function (game) {
 
    // sprite sheet generated by canvas
    var canvas = document.createElement('canvas'),
    ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 32;
 
    // blue frame
    ctx.fillStyle = '#0000ff';
    ctx.fillRect(0, 0, 32, 32);
 
    // red frame
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(32, 0, 32, 32);
 
    game.cache.addSpriteSheet('sheet-block', null, canvas, 32, 32, 2, 0, 0);
 
};
```

#### 2.1.6 - The Spawn method that will create a new Sprite and attach Enemy.onDestroy

```js
// re-spawn a dead enemy
Enemy.spawn = function (a) {
 
    var data = this.game.data,
    enemies = data.enemies;
 
    if (enemies.children.length < data.maxEnemies) {
 
        var enemy = data.enemies.create(0, 0, 'sheet-block');
 
        // attach onDestroy event
        enemy.events.onDestroy.add(Enemy.onDestroy, this);
 
        // attach on input down event
        enemy.inputEnabled = true;
        enemy.events.onInputDown.add(Enemy.onInputDown, this);
 
        enemy.data = Enemy.genSpriteData();
 
    }
 
};
```

#### 2.1.7 - The Enemy.update method to be called on each frame tick

```js
// What needs to happen for each frame tick
Enemy.update = function (game) {
 
    var data = game.data,
    game = game;
 
    // loop all enemies
    data.enemies.forEach(function (enemy) {
 
        // step position based on current deltas
        enemy.x = Phaser.Math.wrap(enemy.x += enemy.data.dx, -32, game.world.width + 32);
        enemy.y = Phaser.Math.wrap(enemy.y += enemy.data.dy, -32, game.world.height + 32);
 
        // call destroy
        if (enemy.data.hp <= 0) {
 
            enemy.destroy();
 
        }
 
    });
 
};
```

### 2.2


#### 2.2.1

```js
var game = new Phaser.Game(320, 240, Phaser.AUTO, 'gamearea');
 
game.state.add('boot', {
 
    create: function () {
 
        // setup game data object
        Enemy.setup(this.game);
 
        Enemy.mkSheet(this.game);
 
        //Enemy.createEnemyPool.call(this);
 
        // start demo, and do not clear the world
        game.state.start('demo',false,false);
 
    }
 
});
```

#### 2.2.2

```js
game.state.add('demo', {
 
    create: function () {
 
        // call Enemy.spawn every second
        game.time.events.loop(1000, Enemy.spawn, this);
 
        // text display object to show score
        var text = game.add.text(5, 5, '', {
                fill: 'white'
            });
        text.name = 'disp-score';
 
    },
 
    update: function () {
 
        var data = this.game.data;
 
        Enemy.update(game);
 
        game.world.getByName('disp-score').text = 'score: ' + data.score;
 
    }
 
});
 
game.state.start('boot');
```

## 3 - Conclusion
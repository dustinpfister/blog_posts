---
title: The Phaser on destroy event
date: 2018-09-15 15:04:00
tags: [js,phaser]
layout: post
categories: phaser
id: 280
updated: 2018-09-15 15:37:44
version: 1.1
---

Recently I wrote a post on the onKilled event that can be used to attach event handlers to display objects in [Phaser ce](https://photonstorm.github.io/phaser-ce/) that will fire when the kill method is called. In phaser ce the kill method is very different from the destroy method in that the kill method will just put a sprite in a dead state, while the destroy method will completely destroy a sprite all together.

<!-- more -->


```js
var Enemy = {};
 
// setup a game.data object
Enemy.setup = function (game) {
 
    game.data = {
 
        maxEnemies: 5,
        enemies: game.add.group(),
        score: 0
 
    };
 
};
```

```js
// The onDestroy method that will be called each time an enemy is killed
Enemy.onDestroy = function (sprite) {
 
    var game = this.game,
    spriteSpeed = (sprite.data.dx + sprite.data.dy) / 8,
    speedBonus = 175, // points bonus for speed.
    perKill = 25; // points per kill
 
    // score formula
    game.data.score += perKill + Math.floor(spriteSpeed * speedBonus);
 
};
```

```js
// What happens when the player clicks an enemy
Enemy.onInputDown = function (enemy) {
 
    enemy.data.hp -= 1;
 
    if (enemy.data.hp === 1) {
        enemy.frame = 1;
    }
 
    if (enemy.data.hp <= 0) {
        enemy.kill();
    }
 
};
```

```js
// generate a data object for a sprite
Enemy.genSpriteData = function () {
 
    return {
        dx: Math.random() * 3.5 + 0.5,
        dy: Math.random() * 3.5 + 0.5,
        hp: 2
    };
 
};
```

```js
// make a sprite sheet
Enemy.mkSheet = function (game) {
 
    // sprite sheet generated by canvas
    var canvas = document.createElement('canvas'),
    ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 32;
 
    // blue frame
    ctx.fillStyle = '#0000ff';
    ctx.fillRect(0, 0, 32, 32);
 
    // red frame
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(32, 0, 32, 32);
 
    game.cache.addSpriteSheet('sheet-block', null, canvas, 32, 32, 2, 0, 0);
 
};
```

```js
// re-spawn a dead enemy
Enemy.spawn = function (a) {
 
    var data = this.game.data,
    enemies = data.enemies;
 
    if (enemies.children.length < data.maxEnemies) {
 
        var enemy = data.enemies.create(0, 0, 'sheet-block');
 
        // attach onDestroy event
        enemy.events.onDestroy.add(Enemy.onDestroy, this);
 
        // attach on input down event
        enemy.inputEnabled = true;
        enemy.events.onInputDown.add(Enemy.onInputDown, this);
 
        enemy.data = Enemy.genSpriteData();
 
    }
 
};
```

```js
// What needs to happen for each frame tick
Enemy.update = function (game) {
 
    var data = game.data,
    game = game;
 
    // loop all enemies
    data.enemies.forEach(function (enemy) {
 
        // step position based on current deltas
        enemy.x = Phaser.Math.wrap(enemy.x += enemy.data.dx, -32, game.world.width + 32);
        enemy.y = Phaser.Math.wrap(enemy.y += enemy.data.dy, -32, game.world.height + 32);
 
        // call destroy
        if (enemy.data.hp <= 0) {
 
            enemy.destroy();
 
        }
 
    });
 
};
```

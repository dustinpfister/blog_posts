---
title: The Phaser on destroy event
date: 2018-09-15 15:04:00
tags: [js,phaser]
layout: post
categories: phaser
id: 280
updated: 2018-09-15 16:02:55
version: 1.5
---

Recently I wrote a post on the onKilled event that can be used to attach event handlers to display objects in [Phaser ce](https://photonstorm.github.io/phaser-ce/) that will fire when the kill method is called. In phaser ce the kill method is very different from the destroy method in that the kill method will just put a sprite in a dead state, while the destroy method will completely destroy a sprite all together.

<!-- more -->

## 1 - what to know

This is a post on the sprite.events.onDestroy event in phaser ce that can be used to define some javaScript that is to be called when a display object such as a sprite is completely removed from phaser using the destroy method.

## 2 - A phaser example using sprite.events.onDestroy


### 2.1 - The enemies.js file

#### 2.1.1 - Staring off the module with Enemy.setup

```js
var Enemy = {};
 
// setup a game.data object
Enemy.setup = function (game) {
 
    game.data = {
 
        maxEnemies: 5,
        enemies: game.add.group(),
        score: 0
 
    };
 
};
```

#### 2.1.2 - The Enemy.onDestroy handler that will be attached to sprite.events.onDestroy

```js
// The onDestroy method that will be called each time an enemy is killed
Enemy.onDestroy = function (sprite) {
 
    var game = this.game,
    spriteSpeed = (sprite.data.dx + sprite.data.dy) / 8,
    speedBonus = 175, // points bonus for speed.
    perKill = 25; // points per kill
 
    // score formula
    game.data.score += perKill + Math.floor(spriteSpeed * speedBonus);
 
};
```

#### 2.1.3 - The Enemy.onInputDown handler

```js
// What happens when the player clicks an enemy
Enemy.onInputDown = function (enemy) {
 
    enemy.data.hp -= 1;
 
    if (enemy.data.hp === 1) {
        enemy.frame = 1;
    }
 
    if (enemy.data.hp <= 0) {
        enemy.kill();
    }
 
};
```

#### 2.1.4 - Generating a Sprite.data object

```js
// generate a data object for a sprite
Enemy.genSpriteData = function () {
 
    return {
        dx: Math.random() * 3.5 + 0.5,
        dy: Math.random() * 3.5 + 0.5,
        hp: 2
    };
 
};
```

#### 2.1.5 - Making a sheet with canvas

```js
// make a sprite sheet
Enemy.mkSheet = function (game) {
 
    // sprite sheet generated by canvas
    var canvas = document.createElement('canvas'),
    ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 32;
 
    // blue frame
    ctx.fillStyle = '#0000ff';
    ctx.fillRect(0, 0, 32, 32);
 
    // red frame
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(32, 0, 32, 32);
 
    game.cache.addSpriteSheet('sheet-block', null, canvas, 32, 32, 2, 0, 0);
 
};
```

#### 2.1.6 - The Spawn method that will create a new Sprite and attach Enemy.onDestroy

```js
// re-spawn a dead enemy
Enemy.spawn = function (a) {
 
    var data = this.game.data,
    enemies = data.enemies;
 
    if (enemies.children.length < data.maxEnemies) {
 
        var enemy = data.enemies.create(0, 0, 'sheet-block');
 
        // attach onDestroy event
        enemy.events.onDestroy.add(Enemy.onDestroy, this);
 
        // attach on input down event
        enemy.inputEnabled = true;
        enemy.events.onInputDown.add(Enemy.onInputDown, this);
 
        enemy.data = Enemy.genSpriteData();
 
    }
 
};
```

#### 2.1.7 - The Enemy.update method to be called on each frame tick

```js
// What needs to happen for each frame tick
Enemy.update = function (game) {
 
    var data = game.data,
    game = game;
 
    // loop all enemies
    data.enemies.forEach(function (enemy) {
 
        // step position based on current deltas
        enemy.x = Phaser.Math.wrap(enemy.x += enemy.data.dx, -32, game.world.width + 32);
        enemy.y = Phaser.Math.wrap(enemy.y += enemy.data.dy, -32, game.world.height + 32);
 
        // call destroy
        if (enemy.data.hp <= 0) {
 
            enemy.destroy();
 
        }
 
    });
 
};
```

### 2.2


#### 2.2.1

```js
var game = new Phaser.Game(320, 240, Phaser.AUTO, 'gamearea');
 
game.state.add('boot', {
 
    create: function () {
 
        // setup game data object
        Enemy.setup(this.game);
 
        Enemy.mkSheet(this.game);
 
        //Enemy.createEnemyPool.call(this);
 
        // start demo, and do not clear the world
        game.state.start('demo',false,false);
 
    }
 
});
```

#### 2.2.2

```js
game.state.add('demo', {
 
    create: function () {
 
        // call Enemy.spawn every second
        game.time.events.loop(1000, Enemy.spawn, this);
 
        // text display object to show score
        var text = game.add.text(5, 5, '', {
                fill: 'white'
            });
        text.name = 'disp-score';
 
    },
 
    update: function () {
 
        var data = this.game.data;
 
        Enemy.update(game);
 
        game.world.getByName('disp-score').text = 'score: ' + data.score;
 
    }
 
});
 
game.state.start('boot');
```

## 3 - Conclusion